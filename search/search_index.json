{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83d\udd10 Serialize JAX, Flax, Haiku, or Objax model params with safetensors safejax is a Python package to serialize JAX, Flax, Haiku, or Objax model params using safetensors as the tensor storage format, instead of relying on pickle . For more details on why safetensors is safer than pickle please check huggingface/safetensors . Note that safejax supports the serialization of jax , flax , dm-haiku , and objax model parameters and has been tested with all those frameworks, but there may be some cases where it does not work as expected, as this is still in an early development phase, so please if you have any feedback or bug reports, open an issue at safejax/issues .","title":"Home"},{"location":"#serialize-jax-flax-haiku-or-objax-model-params-with-safetensors","text":"safejax is a Python package to serialize JAX, Flax, Haiku, or Objax model params using safetensors as the tensor storage format, instead of relying on pickle . For more details on why safetensors is safer than pickle please check huggingface/safetensors . Note that safejax supports the serialization of jax , flax , dm-haiku , and objax model parameters and has been tested with all those frameworks, but there may be some cases where it does not work as expected, as this is still in an early development phase, so please if you have any feedback or bug reports, open an issue at safejax/issues .","title":"\ud83d\udd10 Serialize JAX, Flax, Haiku, or Objax model params with safetensors"},{"location":"examples/","text":"\ud83e\udd16 Examples Here you will find some detailed examples of how to use safejax to serialize model parameters, in opposition to the default way to store those, which uses pickle as the format to store the tensors instead of safetensors . Flax Available at flax_ft_safejax.py . To run this Python script you won't need to install anything else than safejax , as both jax and flax are installed as part of it. In this case, a single-layer model will be created, for now, flax doesn't have any pre-defined architecture such as ResNet, but you can use flaxmodels for that, as it defines some well-known architectures written in flax . import jax from flax import linen as nn class SingleLayerModel ( nn . Module ): features : int @nn . compact def __call__ ( self , x ): x = nn . Dense ( features = self . features )( x ) return x Once the network has been defined, we can instantiate and initialize it, to retrieve the params out of the forward pass performed during .init . import jax from jax import numpy as jnp network = SingleLayerModel ( features = 1 ) rng_key = jax . random . PRNGKey ( seed = 0 ) initial_params = network . init ( rng_key , jnp . ones (( 1 , 1 ))) Right after getting the params from the .init method's output, we can use safejax.serialize to encode those using safetensors , that later on can be loaded back using safejax.deserialize . from safejax import deserialize , serialize encoded_bytes = serialize ( params = initial_params ) decoded_params = deserialize ( path_or_buf = encoded_bytes , freeze_dict = True ) As seen in the code above, we're using freeze_dict=True since its default value is False, as we want to freeze the dict with the params before actually returning it during safejax.deserialize , this transforms the Dict into a FrozenDict . Finally, we can use those decoded_params to run a forward pass with the previously defined single-layer network. x = jnp . ones (( 1 , 1 )) y = network . apply ( decoded_params , x ) Haiku Available at haiku_ft_safejax.py . To run this Python script you'll need to have both safejax and dm-haiku installed. A ResNet50 architecture will be used from haiku.nets.imagenet.resnet and since the purpose of the example is to show the integration of both dm-haiku and safejax , we won't use pre-trained weights. If you're not familiar with dm-haiku , please visit Haiku Basics . First of all, let's create the network instance for the ResNet50 using dm-haiku with the following code: import haiku as hk from jax import numpy as jnp def resnet_fn ( x : jnp . DeviceArray , is_training : bool ): resnet = hk . nets . ResNet50 ( num_classes = 10 ) return resnet ( x , is_training = is_training ) network = hk . without_apply_rng ( hk . transform_with_state ( resnet_fn )) Some notes on the code above: * haiku.nets.ResNet50 requires num_classes as a mandatory parameter * haiku.nets.ResNet50.__call__ requires is_training as a mandatory parameter * It needs to be initialized with hk.transform_with_state as we want to preserve the state e.g. ExponentialMovingAverage in BatchNorm. More information at https://dm-haiku.readthedocs.io/en/latest/api.html#transform-with-state. * Using hk.without_apply_rng removes the rng arg in the .apply function. More information at https://dm-haiku.readthedocs.io/en/latest/api.html#without-apply-rng. Then we just initialize the network to retrieve both the params and the state , which again, are random. import jax rng_key = jax . random . PRNGKey ( seed = 0 ) initial_params , initial_state = network . init ( rng_key , jnp . ones ([ 1 , 224 , 224 , 3 ]), is_training = True ) Now once we have the params , we can import safejax.serialize to serialize the params using safetensors as the tensor storage format, that later on can be loaded back using safejax.deserialize and used for the network's inference. from safejax import deserialize , serialize encoded_bytes = serialize ( params = initial_params ) decoded_params = deserialize ( path_or_buf = encoded_bytes ) Finally, let's just use those decoded_params to run the inference over the network using those weights. x = jnp . ones ([ 1 , 224 , 224 , 3 ]) y , _ = network . apply ( decoded_params , initial_state , x , is_training = False ) Objax Available at objax_ft_safejax.py . To run this Python script you won't need to install anything else than safejax , as both jax and objax are installed as part of it. In this case, we'll be using one of the architectures defined in the model zoo of objax at objax/zoo , which is ResNet50. So first of all, let's initialize it: from objax.zoo.resnet_v2 import ResNet50 model = ResNet50 ( in_channels = 3 , num_classes = 1000 ) Once initialized, we can already access the model params which in objax are stored in model.vars() and are of type VarCollection which is a dictionary-like class. So on, we can already serialize those using safejax.serialize and safetensors format instead of pickle which is the current recommended way, see https://objax.readthedocs.io/en/latest/advanced/io.html. from safejax import serialize encoded_bytes = serialize ( params = model . vars ()) Then we can just deserialize those params back using safejax.deserialize , and we'll end up getting the same VarCollection dictionary back. Note that we need to disable the unflattening with requires_unflattening=False as it's not required due to the way it's stored, and set to_var_collection=True to get a VarCollection instead of a Dict[str, jnp.DeviceArray] , even though it will work with a standard dict too. from safejax import deserialize decoded_params = deserialize ( encoded_bytes , requires_unflattening = False , to_var_collection = True ) Now, once decoded with safejax.deserialize we need to assign those key-value pais back to the VarCollection of the ResNet50 via assignment, as .update in objax has been redefined, see https://github.com/google/objax/blob/53b391bfa72dc59009c855d01b625049a35f5f1b/objax/variable.py#L311, and it's not consistent with the standard dict.update (already reported at https://github.com/google/objax/issues/254). So, instead, we need to loop over all the key-value pairs in the decoded params and assign those one by one to the VarCollection in model.vars() . for key , value in decoded_params . items (): if key not in model . vars (): print ( f \"Key { key } not in model.vars()! Skipping.\" ) continue model . vars ()[ key ] . assign ( value ) And, finally, we can run the inference over the model via the __call__ method as the .vars() are already copied from the params resulting of safejax.deserialize . from jax import numpy as jnp x = jnp . ones (( 1 , 3 , 224 , 224 )) y = model ( x , training = False ) Note that we're setting the training flag to False , which is the standard way of running the inference over a pre-trained model in objax .","title":"Examples"},{"location":"examples/#examples","text":"Here you will find some detailed examples of how to use safejax to serialize model parameters, in opposition to the default way to store those, which uses pickle as the format to store the tensors instead of safetensors .","title":"\ud83e\udd16 Examples"},{"location":"examples/#flax","text":"Available at flax_ft_safejax.py . To run this Python script you won't need to install anything else than safejax , as both jax and flax are installed as part of it. In this case, a single-layer model will be created, for now, flax doesn't have any pre-defined architecture such as ResNet, but you can use flaxmodels for that, as it defines some well-known architectures written in flax . import jax from flax import linen as nn class SingleLayerModel ( nn . Module ): features : int @nn . compact def __call__ ( self , x ): x = nn . Dense ( features = self . features )( x ) return x Once the network has been defined, we can instantiate and initialize it, to retrieve the params out of the forward pass performed during .init . import jax from jax import numpy as jnp network = SingleLayerModel ( features = 1 ) rng_key = jax . random . PRNGKey ( seed = 0 ) initial_params = network . init ( rng_key , jnp . ones (( 1 , 1 ))) Right after getting the params from the .init method's output, we can use safejax.serialize to encode those using safetensors , that later on can be loaded back using safejax.deserialize . from safejax import deserialize , serialize encoded_bytes = serialize ( params = initial_params ) decoded_params = deserialize ( path_or_buf = encoded_bytes , freeze_dict = True ) As seen in the code above, we're using freeze_dict=True since its default value is False, as we want to freeze the dict with the params before actually returning it during safejax.deserialize , this transforms the Dict into a FrozenDict . Finally, we can use those decoded_params to run a forward pass with the previously defined single-layer network. x = jnp . ones (( 1 , 1 )) y = network . apply ( decoded_params , x )","title":"Flax"},{"location":"examples/#haiku","text":"Available at haiku_ft_safejax.py . To run this Python script you'll need to have both safejax and dm-haiku installed. A ResNet50 architecture will be used from haiku.nets.imagenet.resnet and since the purpose of the example is to show the integration of both dm-haiku and safejax , we won't use pre-trained weights. If you're not familiar with dm-haiku , please visit Haiku Basics . First of all, let's create the network instance for the ResNet50 using dm-haiku with the following code: import haiku as hk from jax import numpy as jnp def resnet_fn ( x : jnp . DeviceArray , is_training : bool ): resnet = hk . nets . ResNet50 ( num_classes = 10 ) return resnet ( x , is_training = is_training ) network = hk . without_apply_rng ( hk . transform_with_state ( resnet_fn )) Some notes on the code above: * haiku.nets.ResNet50 requires num_classes as a mandatory parameter * haiku.nets.ResNet50.__call__ requires is_training as a mandatory parameter * It needs to be initialized with hk.transform_with_state as we want to preserve the state e.g. ExponentialMovingAverage in BatchNorm. More information at https://dm-haiku.readthedocs.io/en/latest/api.html#transform-with-state. * Using hk.without_apply_rng removes the rng arg in the .apply function. More information at https://dm-haiku.readthedocs.io/en/latest/api.html#without-apply-rng. Then we just initialize the network to retrieve both the params and the state , which again, are random. import jax rng_key = jax . random . PRNGKey ( seed = 0 ) initial_params , initial_state = network . init ( rng_key , jnp . ones ([ 1 , 224 , 224 , 3 ]), is_training = True ) Now once we have the params , we can import safejax.serialize to serialize the params using safetensors as the tensor storage format, that later on can be loaded back using safejax.deserialize and used for the network's inference. from safejax import deserialize , serialize encoded_bytes = serialize ( params = initial_params ) decoded_params = deserialize ( path_or_buf = encoded_bytes ) Finally, let's just use those decoded_params to run the inference over the network using those weights. x = jnp . ones ([ 1 , 224 , 224 , 3 ]) y , _ = network . apply ( decoded_params , initial_state , x , is_training = False )","title":"Haiku"},{"location":"examples/#objax","text":"Available at objax_ft_safejax.py . To run this Python script you won't need to install anything else than safejax , as both jax and objax are installed as part of it. In this case, we'll be using one of the architectures defined in the model zoo of objax at objax/zoo , which is ResNet50. So first of all, let's initialize it: from objax.zoo.resnet_v2 import ResNet50 model = ResNet50 ( in_channels = 3 , num_classes = 1000 ) Once initialized, we can already access the model params which in objax are stored in model.vars() and are of type VarCollection which is a dictionary-like class. So on, we can already serialize those using safejax.serialize and safetensors format instead of pickle which is the current recommended way, see https://objax.readthedocs.io/en/latest/advanced/io.html. from safejax import serialize encoded_bytes = serialize ( params = model . vars ()) Then we can just deserialize those params back using safejax.deserialize , and we'll end up getting the same VarCollection dictionary back. Note that we need to disable the unflattening with requires_unflattening=False as it's not required due to the way it's stored, and set to_var_collection=True to get a VarCollection instead of a Dict[str, jnp.DeviceArray] , even though it will work with a standard dict too. from safejax import deserialize decoded_params = deserialize ( encoded_bytes , requires_unflattening = False , to_var_collection = True ) Now, once decoded with safejax.deserialize we need to assign those key-value pais back to the VarCollection of the ResNet50 via assignment, as .update in objax has been redefined, see https://github.com/google/objax/blob/53b391bfa72dc59009c855d01b625049a35f5f1b/objax/variable.py#L311, and it's not consistent with the standard dict.update (already reported at https://github.com/google/objax/issues/254). So, instead, we need to loop over all the key-value pairs in the decoded params and assign those one by one to the VarCollection in model.vars() . for key , value in decoded_params . items (): if key not in model . vars (): print ( f \"Key { key } not in model.vars()! Skipping.\" ) continue model . vars ()[ key ] . assign ( value ) And, finally, we can run the inference over the model via the __call__ method as the .vars() are already copied from the params resulting of safejax.deserialize . from jax import numpy as jnp x = jnp . ones (( 1 , 3 , 224 , 224 )) y = model ( x , training = False ) Note that we're setting the training flag to False , which is the standard way of running the inference over a pre-trained model in objax .","title":"Objax"},{"location":"installation/","text":"\u2b07\ufe0f Installation pip install safejax --upgrade","title":"Installation"},{"location":"installation/#installation","text":"pip install safejax --upgrade","title":"\u2b07\ufe0f Installation"},{"location":"license/","text":"\ud83d\udcdd License MIT License Copyright (c) 2022-present Alvaro Bartolome alvarobartt@yahoo.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Copyright (c) 2022-present Alvaro Bartolome alvarobartt@yahoo.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"\ud83d\udcdd License"},{"location":"requirements/","text":"\ud83d\udee0\ufe0f Requirements safejax requires Python 3.7 or above","title":"Requirements"},{"location":"requirements/#requirements","text":"safejax requires Python 3.7 or above","title":"\ud83d\udee0\ufe0f Requirements"},{"location":"usage/","text":"\ud83d\udcbb Usage flax Convert params to bytes in memory from safejax.flax import serialize , deserialize params = model . init ( ... ) encoded_bytes = serialize ( params ) decoded_params = deserialize ( encoded_bytes ) model . apply ( decoded_params , ... ) Convert params to bytes in params.safetensors file from safejax.flax import serialize , deserialize params = model . init ( ... ) encoded_bytes = serialize ( params , filename = \"./params.safetensors\" ) decoded_params = deserialize ( \"./params.safetensors\" ) model . apply ( decoded_params , ... ) dm-haiku Just contains params from safejax.haiku import serialize , deserialize params = model . init ( ... ) encoded_bytes = serialize ( params ) decoded_params = deserialize ( encoded_bytes ) model . apply ( decoded_params , ... ) If it contains params and state e.g. ExponentialMovingAverage in BatchNorm from safejax.haiku import serialize , deserialize params , state = model . init ( ... ) params_state = { \"params\" : params , \"state\" : state } encoded_bytes = serialize ( params_state ) decoded_params_state = deserialize ( encoded_bytes ) # .keys() contains `params` and `state` model . apply ( decoded_params_state [ \"params\" ], decoded_params_state [ \"state\" ], ... ) If it contains params and state , but we want to serialize those individually from safejax.haiku import serialize , deserialize params , state = model . init ( ... ) encoded_bytes = serialize ( params ) decoded_params = deserialize ( encoded_bytes ) encoded_bytes = serialize ( state ) decoded_state = deserialize ( encoded_bytes ) model . apply ( decoded_params , decoded_state , ... ) objax Convert params to bytes in memory, and convert back to VarCollection from safejax.objax import serialize , deserialize params = model . vars () encoded_bytes = serialize ( params = params ) decoded_params = deserialize ( encoded_bytes ) for key , value in decoded_params . items (): if key in model . vars (): model . vars ()[ key ] . assign ( value . value ) model ( ... ) Convert params to bytes in params.safetensors file from safejax.objax import serialize , deserialize params = model . vars () encoded_bytes = serialize ( params = params , filename = \"./params.safetensors\" ) decoded_params = deserialize ( \"./params.safetensors\" ) for key , value in decoded_params . items (): if key in model . vars (): model . vars ()[ key ] . assign ( value . value ) model ( ... ) Convert params to bytes in params.safetensors and assign during deserialization from safejax.objax import serialize , deserialize_with_assignment params = model . vars () encoded_bytes = serialize ( params = params , filename = \"./params.safetensors\" ) deserialize_with_assignment ( filename = \"./params.safetensors\" , model_vars = params ) model ( ... ) More in-detail examples can be found at examples/ for flax , dm-haiku , and objax .","title":"Usage"},{"location":"usage/#usage","text":"","title":"\ud83d\udcbb Usage"},{"location":"usage/#flax","text":"Convert params to bytes in memory from safejax.flax import serialize , deserialize params = model . init ( ... ) encoded_bytes = serialize ( params ) decoded_params = deserialize ( encoded_bytes ) model . apply ( decoded_params , ... ) Convert params to bytes in params.safetensors file from safejax.flax import serialize , deserialize params = model . init ( ... ) encoded_bytes = serialize ( params , filename = \"./params.safetensors\" ) decoded_params = deserialize ( \"./params.safetensors\" ) model . apply ( decoded_params , ... )","title":"flax"},{"location":"usage/#dm-haiku","text":"Just contains params from safejax.haiku import serialize , deserialize params = model . init ( ... ) encoded_bytes = serialize ( params ) decoded_params = deserialize ( encoded_bytes ) model . apply ( decoded_params , ... ) If it contains params and state e.g. ExponentialMovingAverage in BatchNorm from safejax.haiku import serialize , deserialize params , state = model . init ( ... ) params_state = { \"params\" : params , \"state\" : state } encoded_bytes = serialize ( params_state ) decoded_params_state = deserialize ( encoded_bytes ) # .keys() contains `params` and `state` model . apply ( decoded_params_state [ \"params\" ], decoded_params_state [ \"state\" ], ... ) If it contains params and state , but we want to serialize those individually from safejax.haiku import serialize , deserialize params , state = model . init ( ... ) encoded_bytes = serialize ( params ) decoded_params = deserialize ( encoded_bytes ) encoded_bytes = serialize ( state ) decoded_state = deserialize ( encoded_bytes ) model . apply ( decoded_params , decoded_state , ... )","title":"dm-haiku"},{"location":"usage/#objax","text":"Convert params to bytes in memory, and convert back to VarCollection from safejax.objax import serialize , deserialize params = model . vars () encoded_bytes = serialize ( params = params ) decoded_params = deserialize ( encoded_bytes ) for key , value in decoded_params . items (): if key in model . vars (): model . vars ()[ key ] . assign ( value . value ) model ( ... ) Convert params to bytes in params.safetensors file from safejax.objax import serialize , deserialize params = model . vars () encoded_bytes = serialize ( params = params , filename = \"./params.safetensors\" ) decoded_params = deserialize ( \"./params.safetensors\" ) for key , value in decoded_params . items (): if key in model . vars (): model . vars ()[ key ] . assign ( value . value ) model ( ... ) Convert params to bytes in params.safetensors and assign during deserialization from safejax.objax import serialize , deserialize_with_assignment params = model . vars () encoded_bytes = serialize ( params = params , filename = \"./params.safetensors\" ) deserialize_with_assignment ( filename = \"./params.safetensors\" , model_vars = params ) model ( ... ) More in-detail examples can be found at examples/ for flax , dm-haiku , and objax .","title":"objax"},{"location":"why_safejax/","text":"\ud83e\udd14 Why safejax ? safetensors defines an easy and fast (zero-copy) format to store tensors, while pickle has some known weaknesses and security issues. safetensors is also a storage format that is intended to be trivial to the framework used to load the tensors. More in-depth information can be found at huggingface/safetensors . jax uses pytrees to store the model parameters in memory, so it's a dictionary-like class containing nested jnp.DeviceArray tensors. dm-haiku uses a custom dictionary formatted as <level_1>/~/<level_2> , where the levels are the ones that define the tree structure and /~/ is the separator between those e.g. res_net50/~/intial_conv , and that key does not contain a jnp.DeviceArray , but a dictionary with key value pairs e.g. for both weights as w and biases as b . objax defines a custom dictionary-like class named VarCollection that contains some variables inheriting from BaseVar which is another custom objax type. flax defines a dictionary-like class named FrozenDict that is used to store the tensors in memory, it can be dumped either into bytes in MessagePack format or as a state_dict . There are no plans from HuggingFace to extend safetensors to support anything more than tensors e.g. FrozenDict s, see their response at huggingface/safetensors/discussions/138 . So the motivation to create safejax is to easily provide a way to serialize FrozenDict s using safetensors as the tensor storage format instead of pickle , as well as to provide a common and easy way to serialize and deserialize any JAX model params (Flax, Haiku, or Objax) using safetensors format.","title":"Why safejax?"},{"location":"why_safejax/#why-safejax","text":"safetensors defines an easy and fast (zero-copy) format to store tensors, while pickle has some known weaknesses and security issues. safetensors is also a storage format that is intended to be trivial to the framework used to load the tensors. More in-depth information can be found at huggingface/safetensors . jax uses pytrees to store the model parameters in memory, so it's a dictionary-like class containing nested jnp.DeviceArray tensors. dm-haiku uses a custom dictionary formatted as <level_1>/~/<level_2> , where the levels are the ones that define the tree structure and /~/ is the separator between those e.g. res_net50/~/intial_conv , and that key does not contain a jnp.DeviceArray , but a dictionary with key value pairs e.g. for both weights as w and biases as b . objax defines a custom dictionary-like class named VarCollection that contains some variables inheriting from BaseVar which is another custom objax type. flax defines a dictionary-like class named FrozenDict that is used to store the tensors in memory, it can be dumped either into bytes in MessagePack format or as a state_dict . There are no plans from HuggingFace to extend safetensors to support anything more than tensors e.g. FrozenDict s, see their response at huggingface/safetensors/discussions/138 . So the motivation to create safejax is to easily provide a way to serialize FrozenDict s using safetensors as the tensor storage format instead of pickle , as well as to provide a common and easy way to serialize and deserialize any JAX model params (Flax, Haiku, or Objax) using safetensors format.","title":"\ud83e\udd14 Why safejax?"},{"location":"api/core_load/","text":"deserialize ( path_or_buf , fs = None , freeze_dict = False , requires_unflattening = True , to_var_collection = False ) Deserialize JAX, Flax, Haiku, or Objax model params from either a bytes object or a file path, stored using safetensors.flax.save_file or directly saved using safejax.save.serialize with the filename parameter. Note The default behavior of this function is to restore a Dict[str, jnp.DeviceArray] from a bytes object or a file path. If you are using objax , you should set requires_unflattening to False and to_var_collection to True to restore a VarCollection . If you're using flax you should set freeze_dict to True to restore a FrozenDict . Those are just tips on how to use it but all those frameworks are compatible with the default behavior. Parameters: Name Type Description Default path_or_buf Union [ PathLike , bytes ] A bytes object or a file path containing the serialized model params. required fs Union [ AbstractFileSystem , None] The filesystem to use to load the model params. Defaults to None . None freeze_dict bool Whether to freeze the output Dict to be a FrozenDict or not. Defaults to False . False requires_unflattening bool Whether the model params require unflattening or not. Defaults to True . True to_var_collection bool Whether to convert the output Dict to a VarCollection or not. Defaults to False . False Returns: Type Description Union [ ParamsDictLike , Tuple [ ParamsDictLike , Dict [ str , str ]]] A Dict[str, jnp.DeviceArray] , FrozenDict , or VarCollection containing the model params, Union [ ParamsDictLike , Tuple [ ParamsDictLike , Dict [ str , str ]]] or in case path_or_buf is a filename and metadata is not empty, a tuple containing the Union [ ParamsDictLike , Tuple [ ParamsDictLike , Dict [ str , str ]]] model params and the metadata (in that order). Source code in safejax/core/load.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def deserialize ( path_or_buf : Union [ PathLike , bytes ], fs : Union [ AbstractFileSystem , None ] = None , freeze_dict : bool = False , requires_unflattening : bool = True , to_var_collection : bool = False , ) -> Union [ ParamsDictLike , Tuple [ ParamsDictLike , Dict [ str , str ]]]: \"\"\" Deserialize JAX, Flax, Haiku, or Objax model params from either a `bytes` object or a file path, stored using `safetensors.flax.save_file` or directly saved using `safejax.save.serialize` with the `filename` parameter. Note: The default behavior of this function is to restore a `Dict[str, jnp.DeviceArray]` from a `bytes` object or a file path. If you are using `objax`, you should set `requires_unflattening` to `False` and `to_var_collection` to `True` to restore a `VarCollection`. If you're using `flax` you should set `freeze_dict` to `True` to restore a `FrozenDict`. Those are just tips on how to use it but all those frameworks are compatible with the default behavior. Args: path_or_buf: A `bytes` object or a file path containing the serialized model params. fs: The filesystem to use to load the model params. Defaults to `None`. freeze_dict: Whether to freeze the output `Dict` to be a `FrozenDict` or not. Defaults to `False`. requires_unflattening: Whether the model params require unflattening or not. Defaults to `True`. to_var_collection: Whether to convert the output `Dict` to a `VarCollection` or not. Defaults to `False`. Returns: A `Dict[str, jnp.DeviceArray]`, `FrozenDict`, or `VarCollection` containing the model params, or in case `path_or_buf` is a filename and `metadata` is not empty, a tuple containing the model params and the metadata (in that order). \"\"\" metadata = {} if isinstance ( path_or_buf , bytes ): decoded_params = load ( data = path_or_buf ) elif isinstance ( path_or_buf , ( str , Path )): if fs and fs . protocol != \"file\" : if not isinstance ( fs , AbstractFileSystem ): raise ValueError ( \"`fs` must be a `fsspec.AbstractFileSystem` object or `None`,\" f \" not { type ( fs ) } .\" ) with fs . open ( path_or_buf , \"rb\" ) as f : decoded_params = load ( data = f . read ()) else : if fs and fs . protocol == \"file\" : filename = Path ( fs . _strip_protocol ( path_or_buf )) else : filename = ( path_or_buf if isinstance ( path_or_buf , Path ) else Path ( path_or_buf ) ) if not filename . exists or not filename . is_file : raise ValueError ( f \"`path_or_buf` must be a valid file path, not { path_or_buf } .\" ) decoded_params = {} with safe_open ( filename . as_posix (), framework = \"jax\" ) as f : metadata = f . metadata () for k in f . keys (): decoded_params [ k ] = f . get_tensor ( k ) else : raise ValueError ( \"`path_or_buf` must be a `bytes` object or a file path (`str` or\" f \" `pathlib.Path` object), not { type ( path_or_buf ) } .\" ) if to_var_collection : try : return VarCollection ( cast_objax_variables ( params = decoded_params )) except ValueError as e : warnings . warn ( e ) return decoded_params if requires_unflattening : decoded_params = unflatten_dict ( params = decoded_params ) if freeze_dict : return freeze ( decoded_params ) if metadata and len ( metadata ) > 0 : return decoded_params , metadata return decoded_params","title":"safejax.core.load"},{"location":"api/core_load/#safejax.core.load.deserialize","text":"Deserialize JAX, Flax, Haiku, or Objax model params from either a bytes object or a file path, stored using safetensors.flax.save_file or directly saved using safejax.save.serialize with the filename parameter. Note The default behavior of this function is to restore a Dict[str, jnp.DeviceArray] from a bytes object or a file path. If you are using objax , you should set requires_unflattening to False and to_var_collection to True to restore a VarCollection . If you're using flax you should set freeze_dict to True to restore a FrozenDict . Those are just tips on how to use it but all those frameworks are compatible with the default behavior. Parameters: Name Type Description Default path_or_buf Union [ PathLike , bytes ] A bytes object or a file path containing the serialized model params. required fs Union [ AbstractFileSystem , None] The filesystem to use to load the model params. Defaults to None . None freeze_dict bool Whether to freeze the output Dict to be a FrozenDict or not. Defaults to False . False requires_unflattening bool Whether the model params require unflattening or not. Defaults to True . True to_var_collection bool Whether to convert the output Dict to a VarCollection or not. Defaults to False . False Returns: Type Description Union [ ParamsDictLike , Tuple [ ParamsDictLike , Dict [ str , str ]]] A Dict[str, jnp.DeviceArray] , FrozenDict , or VarCollection containing the model params, Union [ ParamsDictLike , Tuple [ ParamsDictLike , Dict [ str , str ]]] or in case path_or_buf is a filename and metadata is not empty, a tuple containing the Union [ ParamsDictLike , Tuple [ ParamsDictLike , Dict [ str , str ]]] model params and the metadata (in that order). Source code in safejax/core/load.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def deserialize ( path_or_buf : Union [ PathLike , bytes ], fs : Union [ AbstractFileSystem , None ] = None , freeze_dict : bool = False , requires_unflattening : bool = True , to_var_collection : bool = False , ) -> Union [ ParamsDictLike , Tuple [ ParamsDictLike , Dict [ str , str ]]]: \"\"\" Deserialize JAX, Flax, Haiku, or Objax model params from either a `bytes` object or a file path, stored using `safetensors.flax.save_file` or directly saved using `safejax.save.serialize` with the `filename` parameter. Note: The default behavior of this function is to restore a `Dict[str, jnp.DeviceArray]` from a `bytes` object or a file path. If you are using `objax`, you should set `requires_unflattening` to `False` and `to_var_collection` to `True` to restore a `VarCollection`. If you're using `flax` you should set `freeze_dict` to `True` to restore a `FrozenDict`. Those are just tips on how to use it but all those frameworks are compatible with the default behavior. Args: path_or_buf: A `bytes` object or a file path containing the serialized model params. fs: The filesystem to use to load the model params. Defaults to `None`. freeze_dict: Whether to freeze the output `Dict` to be a `FrozenDict` or not. Defaults to `False`. requires_unflattening: Whether the model params require unflattening or not. Defaults to `True`. to_var_collection: Whether to convert the output `Dict` to a `VarCollection` or not. Defaults to `False`. Returns: A `Dict[str, jnp.DeviceArray]`, `FrozenDict`, or `VarCollection` containing the model params, or in case `path_or_buf` is a filename and `metadata` is not empty, a tuple containing the model params and the metadata (in that order). \"\"\" metadata = {} if isinstance ( path_or_buf , bytes ): decoded_params = load ( data = path_or_buf ) elif isinstance ( path_or_buf , ( str , Path )): if fs and fs . protocol != \"file\" : if not isinstance ( fs , AbstractFileSystem ): raise ValueError ( \"`fs` must be a `fsspec.AbstractFileSystem` object or `None`,\" f \" not { type ( fs ) } .\" ) with fs . open ( path_or_buf , \"rb\" ) as f : decoded_params = load ( data = f . read ()) else : if fs and fs . protocol == \"file\" : filename = Path ( fs . _strip_protocol ( path_or_buf )) else : filename = ( path_or_buf if isinstance ( path_or_buf , Path ) else Path ( path_or_buf ) ) if not filename . exists or not filename . is_file : raise ValueError ( f \"`path_or_buf` must be a valid file path, not { path_or_buf } .\" ) decoded_params = {} with safe_open ( filename . as_posix (), framework = \"jax\" ) as f : metadata = f . metadata () for k in f . keys (): decoded_params [ k ] = f . get_tensor ( k ) else : raise ValueError ( \"`path_or_buf` must be a `bytes` object or a file path (`str` or\" f \" `pathlib.Path` object), not { type ( path_or_buf ) } .\" ) if to_var_collection : try : return VarCollection ( cast_objax_variables ( params = decoded_params )) except ValueError as e : warnings . warn ( e ) return decoded_params if requires_unflattening : decoded_params = unflatten_dict ( params = decoded_params ) if freeze_dict : return freeze ( decoded_params ) if metadata and len ( metadata ) > 0 : return decoded_params , metadata return decoded_params","title":"deserialize()"},{"location":"api/core_save/","text":"serialize ( params , metadata = None , include_objax_variables = False , filename = None , fs = None ) Serialize JAX, Flax, Haiku, or Objax model params from either FrozenDict , Dict , or VarCollection . If filename is not provided, the serialized model is returned as a bytes object, otherwise the model is saved to the provided filename and the filename is returned. Parameters: Name Type Description Default params ParamsDictLike A FrozenDict , a Dict or a VarCollection containing the model params. required metadata Union [None, Dict [ str , str ]] A Dict containing the metadata to be saved along with the model params. None include_objax_variables bool Whether to include objax.Variable objects in the serialized model params. False filename Union [ PathLike , None] The path to the file where the model params will be saved. None fs Union [ AbstractFileSystem , None] The filesystem to use to save the model params. Defaults to None . None Returns: Type Description Union [ bytes , PathLike ] The serialized model params as a bytes object or the path to the file where the model params were saved. Source code in safejax/core/save.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def serialize ( params : ParamsDictLike , metadata : Union [ None , Dict [ str , str ]] = None , include_objax_variables : bool = False , filename : Union [ PathLike , None ] = None , fs : Union [ AbstractFileSystem , None ] = None , ) -> Union [ bytes , PathLike ]: \"\"\" Serialize JAX, Flax, Haiku, or Objax model params from either `FrozenDict`, `Dict`, or `VarCollection`. If `filename` is not provided, the serialized model is returned as a `bytes` object, otherwise the model is saved to the provided `filename` and the `filename` is returned. Args: params: A `FrozenDict`, a `Dict` or a `VarCollection` containing the model params. metadata: A `Dict` containing the metadata to be saved along with the model params. include_objax_variables: Whether to include `objax.Variable` objects in the serialized model params. filename: The path to the file where the model params will be saved. fs: The filesystem to use to save the model params. Defaults to `None`. Returns: The serialized model params as a `bytes` object or the path to the file where the model params were saved. \"\"\" params = flatten_dict ( params = params , include_objax_variables = include_objax_variables ) if metadata : if any ( not isinstance ( key , str ) or not isinstance ( value , str ) for key , value in metadata . items () ): raise ValueError ( \"If `metadata` is provided (not `None`), it must be a `Dict[str, str]`\" \" object. From the `safetensors` documentation: 'Optional text only\" \" metadata you might want to save in your header. For instance it can\" \" be useful to specify more about the underlying tensors. This is\" \" purely informative and does not affect tensor loading.'\" ) if not filename : warnings . warn ( \"`metadata` param will be ignored when trying to `deserialize` from\" \" bytes, if you want to save the `metadata` to be loaded later, you can\" \" set the `filename` param to dump the `metadata` along with the model\" \" params in a file, either to be loaded back using `deserialize` from\" \" `path_or_buf` or using `safetensors.safe_open`. More information at\" \" https://github.com/huggingface/safetensors/issues/147.\" ) if filename : if not isinstance ( filename , ( str , Path )): raise ValueError ( \"If `filename` is provided (not `None`), it must be a `str` or a\" f \" `pathlib.Path` object, not { type ( filename ) } .\" ) if fs and fs . protocol != \"file\" : if not isinstance ( fs , AbstractFileSystem ): raise ValueError ( \"`fs` must be a `fsspec.AbstractFileSystem` object or `None`,\" f \" not { type ( fs ) } .\" ) temp_filename = tempfile . NamedTemporaryFile ( mode = \"wb\" , suffix = \".safetensors\" , delete = False ) try : temp_filename . write ( save ( tensors = params , metadata = metadata )) finally : temp_filename . close () fs . put_file ( lpath = temp_filename . name , rpath = filename ) os . remove ( temp_filename . name ) else : if fs and fs . protocol == \"file\" : filename = Path ( fs . _strip_protocol ( filename )) else : filename = filename if isinstance ( filename , Path ) else Path ( filename ) if not filename . exists or not filename . is_file : raise ValueError ( f \"`filename` must be a valid file path, not { filename } .\" ) save_file ( tensors = params , filename = filename . as_posix (), metadata = metadata ) return filename return save ( tensors = params , metadata = metadata )","title":"safejax.core.save"},{"location":"api/core_save/#safejax.core.save.serialize","text":"Serialize JAX, Flax, Haiku, or Objax model params from either FrozenDict , Dict , or VarCollection . If filename is not provided, the serialized model is returned as a bytes object, otherwise the model is saved to the provided filename and the filename is returned. Parameters: Name Type Description Default params ParamsDictLike A FrozenDict , a Dict or a VarCollection containing the model params. required metadata Union [None, Dict [ str , str ]] A Dict containing the metadata to be saved along with the model params. None include_objax_variables bool Whether to include objax.Variable objects in the serialized model params. False filename Union [ PathLike , None] The path to the file where the model params will be saved. None fs Union [ AbstractFileSystem , None] The filesystem to use to save the model params. Defaults to None . None Returns: Type Description Union [ bytes , PathLike ] The serialized model params as a bytes object or the path to the file where the model params were saved. Source code in safejax/core/save.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def serialize ( params : ParamsDictLike , metadata : Union [ None , Dict [ str , str ]] = None , include_objax_variables : bool = False , filename : Union [ PathLike , None ] = None , fs : Union [ AbstractFileSystem , None ] = None , ) -> Union [ bytes , PathLike ]: \"\"\" Serialize JAX, Flax, Haiku, or Objax model params from either `FrozenDict`, `Dict`, or `VarCollection`. If `filename` is not provided, the serialized model is returned as a `bytes` object, otherwise the model is saved to the provided `filename` and the `filename` is returned. Args: params: A `FrozenDict`, a `Dict` or a `VarCollection` containing the model params. metadata: A `Dict` containing the metadata to be saved along with the model params. include_objax_variables: Whether to include `objax.Variable` objects in the serialized model params. filename: The path to the file where the model params will be saved. fs: The filesystem to use to save the model params. Defaults to `None`. Returns: The serialized model params as a `bytes` object or the path to the file where the model params were saved. \"\"\" params = flatten_dict ( params = params , include_objax_variables = include_objax_variables ) if metadata : if any ( not isinstance ( key , str ) or not isinstance ( value , str ) for key , value in metadata . items () ): raise ValueError ( \"If `metadata` is provided (not `None`), it must be a `Dict[str, str]`\" \" object. From the `safetensors` documentation: 'Optional text only\" \" metadata you might want to save in your header. For instance it can\" \" be useful to specify more about the underlying tensors. This is\" \" purely informative and does not affect tensor loading.'\" ) if not filename : warnings . warn ( \"`metadata` param will be ignored when trying to `deserialize` from\" \" bytes, if you want to save the `metadata` to be loaded later, you can\" \" set the `filename` param to dump the `metadata` along with the model\" \" params in a file, either to be loaded back using `deserialize` from\" \" `path_or_buf` or using `safetensors.safe_open`. More information at\" \" https://github.com/huggingface/safetensors/issues/147.\" ) if filename : if not isinstance ( filename , ( str , Path )): raise ValueError ( \"If `filename` is provided (not `None`), it must be a `str` or a\" f \" `pathlib.Path` object, not { type ( filename ) } .\" ) if fs and fs . protocol != \"file\" : if not isinstance ( fs , AbstractFileSystem ): raise ValueError ( \"`fs` must be a `fsspec.AbstractFileSystem` object or `None`,\" f \" not { type ( fs ) } .\" ) temp_filename = tempfile . NamedTemporaryFile ( mode = \"wb\" , suffix = \".safetensors\" , delete = False ) try : temp_filename . write ( save ( tensors = params , metadata = metadata )) finally : temp_filename . close () fs . put_file ( lpath = temp_filename . name , rpath = filename ) os . remove ( temp_filename . name ) else : if fs and fs . protocol == \"file\" : filename = Path ( fs . _strip_protocol ( filename )) else : filename = filename if isinstance ( filename , Path ) else Path ( filename ) if not filename . exists or not filename . is_file : raise ValueError ( f \"`filename` must be a valid file path, not { filename } .\" ) save_file ( tensors = params , filename = filename . as_posix (), metadata = metadata ) return filename return save ( tensors = params , metadata = metadata )","title":"serialize()"},{"location":"api/utils/","text":"cast_objax_variables ( params ) Cast the jnp.DeviceArray to their corresponding objax.variable types. Note This function may return the same params if no objax.variable types are found in the keys. Parameters: Name Type Description Default params JaxDeviceArrayDict A Dict containing the params to cast. required Raises: Type Description ValueError If the params were not serialized from a VarCollection object. Returns: Type Description Union [ JaxDeviceArrayDict , ObjaxDict ] A Dict containing the keys without the variable name, and the values Union [ JaxDeviceArrayDict , ObjaxDict ] with the objax.variable objects with .value assigned from the Union [ JaxDeviceArrayDict , ObjaxDict ] jnp.DeviceArray . Source code in safejax/utils.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def cast_objax_variables ( params : JaxDeviceArrayDict , ) -> Union [ JaxDeviceArrayDict , ObjaxDict ]: \"\"\" Cast the `jnp.DeviceArray` to their corresponding `objax.variable` types. Note: This function may return the same `params` if no `objax.variable` types are found in the keys. Args: params: A `Dict` containing the params to cast. Raises: ValueError: If the params were not serialized from a `VarCollection` object. Returns: A `Dict` containing the keys without the variable name, and the values with the `objax.variable` objects with `.value` assigned from the `jnp.DeviceArray`. \"\"\" casted_params = {} for key , value in params . items (): if OBJAX_VARIABLE_SEPARATOR not in key : raise ValueError ( \"The params were not serialized from a `VarCollection` object, since\" \" the type has not been included as part of the key using\" f \" ` { OBJAX_VARIABLE_SEPARATOR } ` as separator at the end of the key.\" \" Returning the same params without casting the `jnp.DeviceArray` to\" \" `objax.variable` types.\" ) key , objax_var_type = key . split ( OBJAX_VARIABLE_SEPARATOR ) casted_params [ key ] = OBJAX_VARIABLES [ objax_var_type ]( value ) return casted_params flatten_dict ( params , key_prefix = None , include_objax_variables = False ) Flatten a Dict , FrozenDict , or VarCollection , for more detailed information on the supported input types check safejax.typing.ParamsDictLike . Note This function is recursive to explore all the nested dictionaries, and the keys are being flattened using the . character. So that the later de-nesting can be done using the . character as a separator. Reference at https://gist.github.com/Narsil/d5b0d747e5c8c299eb6d82709e480e3d Parameters: Name Type Description Default params ParamsDictLike A Dict , FrozenDict , or VarCollection with the params to flatten. required key_prefix Union [ str , None] A prefix to prepend to the keys of the flattened dictionary. None include_objax_variables bool A boolean indicating whether to include the objax.variable types in the keys of the flattened dictionary. False Returns: Type Description Union [ NumpyArrayDict , JaxDeviceArrayDict ] A Dict containing the flattened params as level-1 key-value pairs. Source code in safejax/utils.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def flatten_dict ( params : ParamsDictLike , key_prefix : Union [ str , None ] = None , include_objax_variables : bool = False , ) -> Union [ NumpyArrayDict , JaxDeviceArrayDict ]: \"\"\" Flatten a `Dict`, `FrozenDict`, or `VarCollection`, for more detailed information on the supported input types check `safejax.typing.ParamsDictLike`. Note: This function is recursive to explore all the nested dictionaries, and the keys are being flattened using the `.` character. So that the later de-nesting can be done using the `.` character as a separator. Reference at https://gist.github.com/Narsil/d5b0d747e5c8c299eb6d82709e480e3d Args: params: A `Dict`, `FrozenDict`, or `VarCollection` with the params to flatten. key_prefix: A prefix to prepend to the keys of the flattened dictionary. include_objax_variables: A boolean indicating whether to include the `objax.variable` types in the keys of the flattened dictionary. Returns: A `Dict` containing the flattened params as level-1 key-value pairs. \"\"\" flattened_params = {} for key , value in params . items (): key = f \" { key_prefix } . { key } \" if key_prefix else key if isinstance ( value , ( BaseVar , BaseState )): if include_objax_variables : key = f \" { key }{ OBJAX_VARIABLE_SEPARATOR }{ type ( value ) . __name__ } \" value = value . value if isinstance ( value , ( jnp . DeviceArray , np . ndarray )): flattened_params [ key ] = value continue if isinstance ( value , ( Dict , FrozenDict )): flattened_params . update ( flatten_dict ( params = value , key_prefix = key , include_objax_variables = include_objax_variables , ) ) return flattened_params unflatten_dict ( params ) Unflatten a Dict where the keys should be expanded using the . character as a separator. Note If the params where serialized from a VarCollection object, then the objax.variable types are included in the keys, and since this function just unflattens the dictionary without objax.variable casting, those variables will be ignored and unflattened normally. Anyway, when deserializing objax models you should use safejax.objax.deserialize or just use the function params in safejax.deserialize : requires_unflattening=False and to_var_collection=True . Reference at https://stackoverflow.com/a/63545677. Parameters: Name Type Description Default params Union [ NumpyArrayDict , JaxDeviceArrayDict ] A Dict containing the params to unflatten by expanding the keys. required Returns: Type Description Dict [ str , Any ] An unflattened Dict where the keys are expanded using the . character. Source code in safejax/utils.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def unflatten_dict ( params : Union [ NumpyArrayDict , JaxDeviceArrayDict ]) -> Dict [ str , Any ]: \"\"\" Unflatten a `Dict` where the keys should be expanded using the `.` character as a separator. Note: If the params where serialized from a `VarCollection` object, then the `objax.variable` types are included in the keys, and since this function just unflattens the dictionary without `objax.variable` casting, those variables will be ignored and unflattened normally. Anyway, when deserializing `objax` models you should use `safejax.objax.deserialize` or just use the function params in `safejax.deserialize`: `requires_unflattening=False` and `to_var_collection=True`. Reference at https://stackoverflow.com/a/63545677. Args: params: A `Dict` containing the params to unflatten by expanding the keys. Returns: An unflattened `Dict` where the keys are expanded using the `.` character. \"\"\" unflattened_params = {} warned_user = False for key , value in params . items (): unflattened_params_tmp = unflattened_params if not warned_user and OBJAX_VARIABLE_SEPARATOR in key : warnings . warn ( \"The params were serialized from a `VarCollection` object, \" \"so the `objax.variable` types are included in the keys, \" \"and since this function just unflattens the dictionary \" \"without `objax.variable` casting, those variables will be \" \"ignored and unflattened normally. Anyway, when deserializing \" \"`objax` models you should use `safejax.objax.deserialize` \" \"or just use the function params in `safejax.deserialize`: \" \"`requires_unflattening=False` and `to_var_collection=True`.\" ) warned_user = True key = ( key . split ( OBJAX_VARIABLE_SEPARATOR )[ 0 ] if OBJAX_VARIABLE_SEPARATOR in key else key ) subkeys = key . split ( \".\" ) for subkey in subkeys [: - 1 ]: unflattened_params_tmp = unflattened_params_tmp . setdefault ( subkey , {}) unflattened_params_tmp [ subkeys [ - 1 ]] = value return unflattened_params","title":"safejax.utils"},{"location":"api/utils/#safejax.utils.cast_objax_variables","text":"Cast the jnp.DeviceArray to their corresponding objax.variable types. Note This function may return the same params if no objax.variable types are found in the keys. Parameters: Name Type Description Default params JaxDeviceArrayDict A Dict containing the params to cast. required Raises: Type Description ValueError If the params were not serialized from a VarCollection object. Returns: Type Description Union [ JaxDeviceArrayDict , ObjaxDict ] A Dict containing the keys without the variable name, and the values Union [ JaxDeviceArrayDict , ObjaxDict ] with the objax.variable objects with .value assigned from the Union [ JaxDeviceArrayDict , ObjaxDict ] jnp.DeviceArray . Source code in safejax/utils.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def cast_objax_variables ( params : JaxDeviceArrayDict , ) -> Union [ JaxDeviceArrayDict , ObjaxDict ]: \"\"\" Cast the `jnp.DeviceArray` to their corresponding `objax.variable` types. Note: This function may return the same `params` if no `objax.variable` types are found in the keys. Args: params: A `Dict` containing the params to cast. Raises: ValueError: If the params were not serialized from a `VarCollection` object. Returns: A `Dict` containing the keys without the variable name, and the values with the `objax.variable` objects with `.value` assigned from the `jnp.DeviceArray`. \"\"\" casted_params = {} for key , value in params . items (): if OBJAX_VARIABLE_SEPARATOR not in key : raise ValueError ( \"The params were not serialized from a `VarCollection` object, since\" \" the type has not been included as part of the key using\" f \" ` { OBJAX_VARIABLE_SEPARATOR } ` as separator at the end of the key.\" \" Returning the same params without casting the `jnp.DeviceArray` to\" \" `objax.variable` types.\" ) key , objax_var_type = key . split ( OBJAX_VARIABLE_SEPARATOR ) casted_params [ key ] = OBJAX_VARIABLES [ objax_var_type ]( value ) return casted_params","title":"cast_objax_variables()"},{"location":"api/utils/#safejax.utils.flatten_dict","text":"Flatten a Dict , FrozenDict , or VarCollection , for more detailed information on the supported input types check safejax.typing.ParamsDictLike . Note This function is recursive to explore all the nested dictionaries, and the keys are being flattened using the . character. So that the later de-nesting can be done using the . character as a separator. Reference at https://gist.github.com/Narsil/d5b0d747e5c8c299eb6d82709e480e3d Parameters: Name Type Description Default params ParamsDictLike A Dict , FrozenDict , or VarCollection with the params to flatten. required key_prefix Union [ str , None] A prefix to prepend to the keys of the flattened dictionary. None include_objax_variables bool A boolean indicating whether to include the objax.variable types in the keys of the flattened dictionary. False Returns: Type Description Union [ NumpyArrayDict , JaxDeviceArrayDict ] A Dict containing the flattened params as level-1 key-value pairs. Source code in safejax/utils.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def flatten_dict ( params : ParamsDictLike , key_prefix : Union [ str , None ] = None , include_objax_variables : bool = False , ) -> Union [ NumpyArrayDict , JaxDeviceArrayDict ]: \"\"\" Flatten a `Dict`, `FrozenDict`, or `VarCollection`, for more detailed information on the supported input types check `safejax.typing.ParamsDictLike`. Note: This function is recursive to explore all the nested dictionaries, and the keys are being flattened using the `.` character. So that the later de-nesting can be done using the `.` character as a separator. Reference at https://gist.github.com/Narsil/d5b0d747e5c8c299eb6d82709e480e3d Args: params: A `Dict`, `FrozenDict`, or `VarCollection` with the params to flatten. key_prefix: A prefix to prepend to the keys of the flattened dictionary. include_objax_variables: A boolean indicating whether to include the `objax.variable` types in the keys of the flattened dictionary. Returns: A `Dict` containing the flattened params as level-1 key-value pairs. \"\"\" flattened_params = {} for key , value in params . items (): key = f \" { key_prefix } . { key } \" if key_prefix else key if isinstance ( value , ( BaseVar , BaseState )): if include_objax_variables : key = f \" { key }{ OBJAX_VARIABLE_SEPARATOR }{ type ( value ) . __name__ } \" value = value . value if isinstance ( value , ( jnp . DeviceArray , np . ndarray )): flattened_params [ key ] = value continue if isinstance ( value , ( Dict , FrozenDict )): flattened_params . update ( flatten_dict ( params = value , key_prefix = key , include_objax_variables = include_objax_variables , ) ) return flattened_params","title":"flatten_dict()"},{"location":"api/utils/#safejax.utils.unflatten_dict","text":"Unflatten a Dict where the keys should be expanded using the . character as a separator. Note If the params where serialized from a VarCollection object, then the objax.variable types are included in the keys, and since this function just unflattens the dictionary without objax.variable casting, those variables will be ignored and unflattened normally. Anyway, when deserializing objax models you should use safejax.objax.deserialize or just use the function params in safejax.deserialize : requires_unflattening=False and to_var_collection=True . Reference at https://stackoverflow.com/a/63545677. Parameters: Name Type Description Default params Union [ NumpyArrayDict , JaxDeviceArrayDict ] A Dict containing the params to unflatten by expanding the keys. required Returns: Type Description Dict [ str , Any ] An unflattened Dict where the keys are expanded using the . character. Source code in safejax/utils.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def unflatten_dict ( params : Union [ NumpyArrayDict , JaxDeviceArrayDict ]) -> Dict [ str , Any ]: \"\"\" Unflatten a `Dict` where the keys should be expanded using the `.` character as a separator. Note: If the params where serialized from a `VarCollection` object, then the `objax.variable` types are included in the keys, and since this function just unflattens the dictionary without `objax.variable` casting, those variables will be ignored and unflattened normally. Anyway, when deserializing `objax` models you should use `safejax.objax.deserialize` or just use the function params in `safejax.deserialize`: `requires_unflattening=False` and `to_var_collection=True`. Reference at https://stackoverflow.com/a/63545677. Args: params: A `Dict` containing the params to unflatten by expanding the keys. Returns: An unflattened `Dict` where the keys are expanded using the `.` character. \"\"\" unflattened_params = {} warned_user = False for key , value in params . items (): unflattened_params_tmp = unflattened_params if not warned_user and OBJAX_VARIABLE_SEPARATOR in key : warnings . warn ( \"The params were serialized from a `VarCollection` object, \" \"so the `objax.variable` types are included in the keys, \" \"and since this function just unflattens the dictionary \" \"without `objax.variable` casting, those variables will be \" \"ignored and unflattened normally. Anyway, when deserializing \" \"`objax` models you should use `safejax.objax.deserialize` \" \"or just use the function params in `safejax.deserialize`: \" \"`requires_unflattening=False` and `to_var_collection=True`.\" ) warned_user = True key = ( key . split ( OBJAX_VARIABLE_SEPARATOR )[ 0 ] if OBJAX_VARIABLE_SEPARATOR in key else key ) subkeys = key . split ( \".\" ) for subkey in subkeys [: - 1 ]: unflattened_params_tmp = unflattened_params_tmp . setdefault ( subkey , {}) unflattened_params_tmp [ subkeys [ - 1 ]] = value return unflattened_params","title":"unflatten_dict()"}]}